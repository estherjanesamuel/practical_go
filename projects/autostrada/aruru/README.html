<!DOCTYPE html>
<html>
<head>
<title>README</title>

<style>
        .copy {
            max-width: 700px; font-family: sans-serif; margin: 0 auto; line-height: 1.5;
        }
        pre {
            background-color: #eee;
            padding: 1em;
            padding-top: 0;
            overflow: auto;
        }
        table {
            border-collapse: collapse;
            width: 100%;
        }
        table+table {
            margin-top: 2em;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 0.5em;
            vertical-align: top;
        }
        td:first-child {
            width: 170px;
        }
        td code {
            white-space: nowrap;
        }
        samp {
            color: rgb(110, 110, 110);
        }
</style>
</head>
<body>
<div class="copy">
<h1>README</h1>
<p>This codebase has been generated by <a href="https://autostrada.dev/">Autostrada</a>.</p>
<h2>Getting started</h2>
<p>Make sure that you're in the root of the project directory and run the <code>cmd/web</code> application using <code>go run</code>:</p>
<pre><code>
$ go run ./cmd/web
</code></pre>
<p>Then visit <a href="http://localhost:4444">http://localhost:4444</a> in your browser.</p>
<h2>Project structure</h2>
<p>Everything in the codebase is designed to be editable. Feel free to change and adapt it to meet your needs.</p>
<table>
<tbody>
<tr>
<td><strong><code>assets</code></strong></td>
<td>Contains the non-code assets for the application.</td>
</tr>
<tr>
<td><code>↳ assets/static/</code></td>
<td>Contains static UI files (images, CSS etc).</td>
</tr>
<tr>
<td><code>↳ assets/templates/</code></td>
<td>Contains HTML templates.</td>
</tr>
<tr>
<td><code>↳ assets/efs.go</code></td>
<td>Declares an embedded filesystem containing all the assets.</td>
</tr>
</tbody>
</table>
<table>
<tbody>
<tr>
<td><strong><code>cmd/web</code></strong></td>
<td>Your application-specific code (handlers, routing, middleware, helpers) for dealing with HTTP requests and responses.</td>
</tr>
<tr>
<td><code>↳ cmd/web/errors.go</code></td>
<td>Contains helpers for managing and responding to error conditions.</td>
</tr>
<tr>
<td><code>↳ cmd/web/handlers.go</code></td>
<td>Contains your application HTTP handlers.</td>
</tr>
<tr>
<td><code>↳ cmd/web/main.go</code></td>
<td>The entry point for the application. Responsible for parsing configuration settings initializing dependencies and running the server. Start here when you're looking through the code.</td>
</tr>
<tr>
<td><code>↳ cmd/web/middleware.go</code></td>
<td>Contains your application middleware.</td>
</tr>
<tr>
<td><code>↳ cmd/web/routes.go</code></td>
<td>Contains your application route mappings.</td>
</tr>
<tr>
<td><code>↳ cmd/web/templates.go</code></td>
<td>Contains helpers for working with HTML templates.</td>
</tr>
</tbody>
</table>
<table>
<tbody>
<tr>
<td><strong><code>internal</code></strong></td>
<td>Contains various helper packages used by the application.</td>
</tr>
<tr>
<td><code>↳ internal/funcs/</code></td>
<td>Contains custom template functions.</td>
</tr>
<tr>
<td><code>↳ internal/request/</code></td>
<td>Contains helper functions for decoding HTML forms and URL query strings.</td>
</tr>
<tr>
<td><code>↳ internal/response/</code></td>
<td>Contains helper functions for rendering HTML templates.</td>
</tr>
<tr>
<td><code>↳ internal/server/</code></td>
<td>Contains a helper function for starting and gracefully shutting down the server.</td>
</tr>
<tr>
<td><code>↳ internal/validator/</code></td>
<td>Contains validation helpers.</td>
</tr>
<tr>
<td><code>↳ internal/version/</code></td>
<td>Contains the application version number definition.</td>
</tr>
</tbody>
</table>
<h2>Configuration settings</h2>
<p>Configuration settings are managed via command-line flags in <code>main.go</code>.</p>
<p>You can try this out by using the <code>-addr</code> flag to configure the network address that the server is listening:</p>
<pre><code>
$ go run . --addr=:9999
</code></pre>
<p>Feel free to adapt the <code>main()</code> function to parse additional command-line flags and store their values in the <code>config</code> struct. For example, to add a configuration setting to enable a 'debug mode' in your application you could do this:</p>
<pre><code>
type config struct {
    addr string
    debug bool
}

...

func main() {
    var cfg config

    flag.StringVar(&amp;cfg.addr, "addr", ":4444", "server address")
    flag.BoolVar(&amp;cfg.debug, "debug", false, "enable debug mode")

    flag.Parse()

    ...
}
</code></pre>
<p>If you don't want to use command-line flags for configuration that's fine. Feel free to adapt the code so that the <code>config</code> struct is populated from environment variables or a settings file instead.</p>
<h2>Creating new handlers</h2>
<p>Handlers are defined as <code>http.HandlerFunc</code> methods on the <code>application</code> struct. They take the pattern:</p>
<pre><code>
func (app *application) yourHandler(w http.ResponseWriter, r *http.Request) {
    // Your handler logic...
}
</code></pre>
<p>Handlers are defined in the <code>cmd/web/handlers.go</code> file. For small applications, it's fine for all handlers to live in this file. For larger applications (10+ handlers) you may wish to break them out into separate files.</p>
<h2>Handler dependencies</h2>
<p>Any dependencies that your handlers have should be initialized in the <code>main()</code> function <code>cmd/web/main.go</code> and added to the <code>application</code> struct. All of your handlers, helpers and middleware that are defined as methods on <code>application</code> will then have access to them.</p>
<p>You can see an example of this in the <code>cmd/web/main.go</code> file where we initialize a new <code>logger</code> instance and add it to the <code>application</code> struct.</p>
<h2>Creating new routes</h2>
<p><a href="https://github.com/alexedwards/flow/">Flow</a> is used for routing, but it's fine to swap to a different router if you want.</p>
<p>Routes are defined in the <code>routes()</code> method in the <code>cmd/web/routes.go</code> file. For example:</p>
<pre><code>
func (app *application) routes() http.Handler {
    mux := flow.New()
    
    mux.HandleFunc("/your/path", app.yourHandler, "GET")
    
    return mux
}
</code></pre>
<p>For more information on using flow and example usage, please see the <a href="https://github.com/alexedwards/flow/">official documentation</a>.</p>
<h2>Adding middleware</h2>
<p>Middleware is defined as methods on the <code>application</code> struct in the <code>cmd/web/middleware.go</code> file. Feel free to add your own. They take the pattern:</p>
<pre><code>
func (app *application) yourMiddleware(next http.Handler) http.Handler {
    return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
        // Your middleware logic...
        next.ServeHTTP(w, r)
    })
}
</code></pre>
<p>You can then register this middleware with the router using the <code>Use()</code> method:</p>
<pre><code>
func (app *application) routes() http.Handler {
    mux := flow.New()
    mux.Use(app.yourMiddleware)
    
    mux.HandleFunc("/your/path", app.yourHandler, "GET")
    
    return mux
}
</code></pre>
<p>It's possible to use middleware on specific routes only by creating route 'groups':</p>
<pre><code>
func (app *application) routes() http.Handler {
    mux := flow.New()
    mux.Use(app.yourMiddleware)
    
    mux.HandleFunc("/your/path", app.yourHandler, "GET")

    mux.Group(func(mux *flow.Mux) {
        mux.Use(app.yourOtherMiddleware)
    
        mux.HandleFunc("/your/other/path", app.yourOtherHandler, "GET")
    })
    
    return mux
}
</code></pre>
<p>Note: Route 'groups' can also be nested.</p>
<h2>Rendering HTML templates</h2>
<p>HTML templates are stored in the <code>assets/templates</code> directory and use the standard library <code>html/template</code> package. The structure looks like this:</p>
<table>
<tbody>
<tr>
<td><code>assets/templates/base.tmpl</code></td>
<td>The 'base' template containing the shared HTML markup for all your web pages.</td>
</tr>
<tr>
<td><code>assets/templates/pages/</code></td>
<td>Directory containing files with the page-specific content for your web pages. See <code>assets/templates/pages/home.tmpl</code> for an example.</td>
</tr>
<tr>
<td><code>assets/templates/partials/</code></td>
<td>Directory containing files with 'partials' to embed in your web pages or base template. See <code>assets/templates/partials/footer.tmpl</code> for an example.</td>
</tr>
</tbody>
</table>
<p>The HTML for web pages can be sent using the <code>response.Page()</code> function. For convenience, an <code>app.newTemplateData()</code> method is provided which returns a <code>map[string]any</code> map. You can add data to this map and pass it on to your templates.</p>
<p>For example, to render the HTML in the <code>assets/templates/pages/example.tmpl</code> file:</p>
<pre><code>
func (app *application) yourHandler(w http.ResponseWriter, r *http.Request) {
    data := app.newTemplateData()
    data["hello"] = "world"

    err := response.Page(w, http.StatusOK, data, "pages/example.tmpl")
    if err != nil {
        app.serverError(w, r, err)
    }
}
</code></pre>
<p>Specific HTTP headers can optionally be sent with the response too:</p>
<pre><code>
func (app *application) yourHandler(w http.ResponseWriter, r *http.Request) {
    data := app.newTemplateData()
    data["hello"] = "world"

    headers := make(http.Header)
    headers.Set("X-Server", "Go")

    err := response.PageWithHeaders(w, http.StatusOK, data, headers, "pages/example.tmpl")
    if err != nil {
        app.serverError(w, r, err)
    }
}
</code></pre>
<p>Note: All the files in the <code>assets/templates</code> directory are embedded into your application binary and can be accessed via the <code>EmbeddedFiles</code> variable in <code>assets/efs.go</code>.</p>
<h2>Adding default template data</h2>
<p>If you have data that you want to display or use on multiple web pages, you can adapt the <code>newTemplateData()</code> helper in the <code>templates.go</code> file to include this by default. For example, if you wanted to include the current year value you could adapt it like this:</p>
<pre><code>
func (app *application) newTemplateData() map[string]any {
    data := map[string]any{
        "CurrentYear": time.Now().Year(),
    }

    return data
}    
</code></pre>
<h2>Custom template functions</h2>
<p>Custom template functions are defined in <code>internal/funcs/funcs.go</code> and are automatically made available to your HTML templates when you use <code>response.Page()</code> .</p>
<p>The following custom template functions are already included by default:</p>
<table>
<tbody>
<tr>
<td><code>now</code></td>
<td>Returns the current time.</td>
</tr>
<tr>
<td><code>timeSince arg1</code></td>
<td>Returns the time elapsed since arg1.</td>
</tr>
<tr>
<td><code>timeUntil arg2</code></td>
<td>Returns the time until arg1.</td>
</tr>
<tr>
<td><code>formatTime arg1 arg2</code></td>
<td>Returns the time arg2 as formatted using the pattern arg1.</td>
</tr>
<tr>
<td><code>approxDuration arg1</code></td>
<td>Returns the approximate duration of arg1 in a 'human-friendly' format ("3 seconds", "2 months", "5 years") etc.</td>
</tr>
<tr>
<td><code>uppercase arg1</code></td>
<td>Returns arg1 converted to uppercase.</td>
</tr>
<tr>
<td><code>lowercase arg1</code></td>
<td>Returns arg1 converted to lowercase.</td>
</tr>
<tr>
<td><code>pluralize arg1 arg2 arg3</code></td>
<td>If arg1 equals 1 then return arg2, otherwise return arg3.</td>
</tr>
<tr>
<td><code>slugify arg1</code></td>
<td>Returns the lowercase of arg1 with all non-ASCII characters and punctuation removed (expect underscores and hyphens). Whitespaces are also replaced with a hyphen.</td>
</tr>
<tr>
<td><code>safeHTML arg1</code></td>
<td>Output the verbatim value of arg1 without escaping the content. This should only be used when arg1 is from a trusted source.</td>
</tr>
<tr>
<td><code>join arg1 arg2</code></td>
<td>Returns the values in arg1 joined using the separator arg2.</td>
</tr>
<tr>
<td><code>containsString arg1 arg2</code></td>
<td>Returns true if arg1 contains the string value arg2.</td>
</tr>
<tr>
<td><code>incr arg1</code></td>
<td>Increments arg1 by 1.</td>
</tr>
<tr>
<td><code>decr arg1</code></td>
<td>Decrements arg1 by 1.</td>
</tr>
<tr>
<td><code>formatInt arg1</code></td>
<td>Returns arg1 formatted with commas as the thousands separator.</td>
</tr>
<tr>
<td><code>formatFloat arg1 arg2</code></td>
<td>Returns arg1 rounded to arg2 decimal places and formatted with commas as the thousands separator.</td>
</tr>
<tr>
<td><code>yesno arg1</code></td>
<td>Returns "Yes" if arg1 is true, or "No" if arg1 is false.</td>
</tr>
<tr>
<td><code>urlSetParam arg1 arg2 arg3</code></td>
<td>Returns the URL arg1 with the key arg2 and value arg3 added to the query string parameters.</td>
</tr>
<tr>
<td><code>urlDelParam arg1 arg2</code></td>
<td>Returns the URL arg1 with the key arg2 (and corresponding value) removed from the query string parameters.</td>
</tr>
</tbody>
</table>
<p>To add another custom template function, define the function in <code>internal/funcs/funcs.go</code> and add it to the <code>TemplateFuncs</code> map. For example:</p>
<pre><code>
var TemplateFuncs = template.FuncMap{
    ...
    "yourFunction": yourFunction, 
}

func yourFunction(s string) (string, error) {
    // Do something...
}
</code></pre>
<h2>Static files</h2>
<p>By default, the files in the <code>assets/static</code> directory are served using Go's <code>http.Fileserver</code> whenever the application receives a <code>GET</code> request with a path beginning <code>/static/</code>. So, for example, if the application receives a <code>GET /static/css/main.css</code> request it will respond with the contents of the <code>assets/static/css/main.css</code> file.</p>
<p>If you want to change or remove this behavior you can by editing the <code>routes.go</code> file.</p>
<p>Note: The files in <code>assets/static</code> directory are embedded into your application binary and can be accessed via the <code>EmbeddedFiles</code> variable in <code>assets/efs.go</code>.</p>
<h2>Working with forms</h2>
<p>The codebase includes a <code>request.DecodePostForm()</code> function for automatically decoding HTML form data into a struct, and <code>request.DecodeQueryString()</code> for decoding URL query strings into a struct. Behind the scenes this decoding is managed using the <a href="https://github.com/go-playground/form">go-playground/form</a> package.</p>
<p>As an example, let's say you have a page with the following HTML form for creating a 'person' record and routing rule:</p>
<pre><code>
&lt;form action="/person/create" method="POST"&gt;
    &lt;div&gt;
        &lt;label&gt;Your name:&lt;/label&gt;
        &lt;input type="text" name="Name" value="{{.Form.Name}}"&gt;
    &lt;/div&gt;
    &lt;div&gt;
        &lt;label&gt;Your age:&lt;/label&gt;
        &lt;input type="number" name="Age" value="{{.Form.Age}}"&gt;
    &lt;/div&gt;
    &lt;button&gt;Submit&lt;/button&gt;
&lt;/form&gt;
</code></pre>
<pre><code>
func (app *application) routes() http.Handler {
    mux := flow.New()
    
    mux.HandleFunc("/person/create", app.createPerson, "GET", "POST")
    
    return mux
}
</code></pre>
<p>Then you can display and parse this form with a <code>createPerson</code> handler like this:</p>
<pre><code>
package main

import (
    "net/http"

    "example.com/internal/request"
    "example.com/internal/response"
)

func (app *application) createPerson(w http.ResponseWriter, r *http.Request) {
    type createPersonForm struct {
        Name string `form:"Name"`
        Age  int    `form:"Age"`
    }

    switch r.Method {
    case http.MethodGet:
        data := app.newTemplateData()

        // Add any default values to the form.
        data["Form"] = createPersonForm{
            Age: 21,
        }

        err := response.Page(w, http.StatusOK, data, "/path/to/page.tmpl")
        if err != nil {
            app.serverError(w, r, err)
        }

    case http.MethodPost:
        var form createPersonForm

        err := request.DecodePostForm(r, &amp;form)
        if err != nil {
            app.badRequest(w, r, err)
            return
        }
    
        // Do something with the data in the form variable...
    }
}    
</code></pre>
<h2>Validating forms</h2>
<p>The <code>internal/validator</code> package includes a simple (but powerful) <code>validator.Validator</code> type that you can use to carry out validation checks.</p>
<p>Extending the example above:</p>
<pre><code>
package main

import (
    "net/http"

    "example.com/internal/request"
    "example.com/internal/response"
    "example.com/internal/validator"
)

func (app *application) createPerson(w http.ResponseWriter, r *http.Request) {
    type createPersonForm struct {
        Name      string              `form:"Name"`
        Age       int                 `form:"Age"`
        Validator validator.Validator `form:"-"`
    }

    switch r.Method {
    case http.MethodGet:
        data := app.newTemplateData()

        // Add any default values to the form.
        data["Form"] = createPersonForm{
            Age: 21,
        }

        err := response.Page(w, http.StatusOK, data, "/path/to/page.tmpl")
        if err != nil {
            app.serverError(w, r, err)
        }

    case http.MethodPost:
        var form createPersonForm

        err := request.DecodePostForm(r, &amp;form)
        if err != nil {
            app.badRequest(w, r, err)
            return
        }

        form.Validator.CheckField(form.Name != "", "Name", "Name is required")
        form.Validator.CheckField(form.Age != 0, "Age", "Age is required")
        form.Validator.CheckField(form.Age &gt;= 21, "Age", "Age must be 21 or over")

        if form.Validator.HasErrors() {
            data := app.newTemplateData()
            data["Form"] = form

            err := response.Page(w, http.StatusUnprocessableEntity, data, "/path/to/page.tmpl")
            if err != nil {
                app.serverError(w, r, err)
            }
            return
        }

        // Do something with the form information, like adding it to a database...
    }
}    
</code></pre>
<p>And you can display the error messages in your HTML form like this:</p>
<pre><code>
&lt;form action="/person/create" method="POST"&gt;
    {{if .Form.Validator.HasErrors}}
        &lt;p&gt;Something was wrong. Please correct the errors below and try again.&lt;/p&gt;
    {{end}}
    &lt;div&gt;
        &lt;label&gt;Your name:&lt;/label&gt;
        {{with .Form.Validator.FieldErrors.Name}}
            &lt;span class='error'&gt;{{.}}&lt;/span&gt;
        {{end}}
        &lt;input type="text" name="Name" value="{{.Form.Name}}"&gt;
    &lt;/div&gt;
    &lt;div&gt;
        &lt;label&gt;Your age:&lt;/label&gt;
        {{with .Form.Validator.FieldErrors.Age}}
            &lt;span class='error'&gt;{{.}}&lt;/span&gt;
        {{end}}
        &lt;input type="number" name="Age" value="{{.Form.Age}}"&gt;
    &lt;/div&gt;
    &lt;button&gt;Submit&lt;/button&gt;
&lt;/form&gt;
</code></pre>
<p>In the example above we use the <code>CheckField()</code> method to carry out validation checks for specific fields. You can also use the <code>Check()</code> method to carry out a validation check that is <em>not related to a specific field</em>. For example:</p>
<pre><code>
input.Validator.Check(input.Password == input.ConfirmPassword, "Passwords do not match")
</code></pre>
<p>The <code>validator.AddError()</code> and <code>validator.AddFieldError()</code> methods also let you add validation errors directly:</p>
<pre><code>
input.Validator.AddFieldError("Email", "This email address is already taken")
input.Validator.AddError("Passwords do not match")
</code></pre>
<p>The <code>internal/validator/helpers.go</code> file also contains some helper functions to simplify validations that are not simple comparison operations.</p>
<table>
<tbody>
<tr>
<td><code>NotBlank(value string)</code></td>
<td>Check that the value contains at least one non-whitespace character.</td>
</tr>
<tr>
<td><code>MinRunes(value string, n int)</code></td>
<td>Check that the value contains at least n runes.</td>
</tr>
<tr>
<td><code>MaxRunes(value string, n int)</code></td>
<td>Check that the value contains no more than n runes.</td>
</tr>
<tr>
<td><code>Between(value, min, max T)</code></td>
<td>Check that the value is between the min and max values inclusive.</td>
</tr>
<tr>
<td><code>Matches(value string, rx *regexp.Regexp)</code></td>
<td>Check that the value matches a specific regular expression.</td>
</tr>
<tr>
<td><code>In(value T, safelist ...T)</code></td>
<td>Check that a value is in a 'safelist' of specific values.</td>
</tr>
<tr>
<td><code>AllIn(values []T, safelist ...T)</code></td>
<td>Check that all values in a slice are in a 'safelist' of specific values.</td>
</tr>
<tr>
<td><code>NotIn(value T, blocklist ...T)</code></td>
<td>Check that the value is not in a 'blocklist' of specific values.</td>
</tr>
<tr>
<td><code>NoDuplicates(values []T)</code></td>
<td>Check that a slice does not contain any duplicate (repeated) values.</td>
</tr>
<tr>
<td><code>IsEmail(value string)</code></td>
<td>Check that the value has the formatting of a valid email address.</td>
</tr>
<tr>
<td><code>IsURL(value string)</code></td>
<td>Check that the value has the formatting of a valid URL.</td>
</tr>
</tbody>
</table>
<p>For example, to use the <code>Between</code> check your code would look similar to this:</p>
<pre><code>
input.Validator.CheckField(validator.Between(input.Age, 18, 30), "Age", "Age must between 18 and 30")
</code></pre>
<p>Feel free to add your own helper functions to the <code>internal/validator/helpers.go</code> file as necessary for your application.</p>
<h2>Application version</h2>
<p>The application version number is defined in a <code>Get()</code> function in the <code>internal/version/version.go</code> file. Feel free to change this as necessary.</p>
<pre><code>
package version

func Get() string {
    return "0.0.1"
}
</code></pre>
<h2>Changing the module path</h2>
<p>The module path is currently set to <code>example.com</code>. Please find and replace all instances of <code>example.com</code> in the codebase with your own module path.</p>
</div>
<!--------------------------------------------------------------------
Admin
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
HTTPS
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Module path
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Version
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Logging
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Database
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Config
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Web:Templates
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Web:Static
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Web:Forms
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
API:Sending
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
API:Decoding
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Funcs
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Validator
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Middleware
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Middleware
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Middleware
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Structure
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Start
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Migrations
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Basic Auth
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Sessions
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
SMTP
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
ACCOUNTS (WEB)
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
ACCOUNTS (API)
------------------------------------------------------------------ -->
<!--------------------------------------------------------------------
Cookies
------------------------------------------------------------------ -->
</body>
</html>
